<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grille Tetris</title>
    <style>
        .game-container {
            position: relative;
            width: 300px; /* Largeur égale à celle de la grille */
            height: 600px; /* Hauteur égale à celle de la grille */
            margin-left: auto;
            margin-right: auto;
        }
        .grid {
            margin-left: auto;
            margin-right: auto;
            display: grid;
            grid-template-columns: repeat(10, 30px); /* 20 colonnes */ 
            grid-template-rows: repeat(20, 30px); /* 10 lignes */ 
            gap: 0px;
            position: relative;
            width: 300px;
            height: 600px;
            border: 3px solid black;
        }
        .cell {
            box-sizing: border-box;
            width: 30px;
            height: 30px;
            background-color: rgb(255, 255, 255);
            border: 1px solid #d5d5d5;
        }
        .cell.active {
            background-color: #6ef740; /* Couleur de la pièce active */ 
            border: 3px solid #000000;
        }
        .cell.square {
            background-color: red; /* Couleur du carré */
        }

        .cell.t {
            background-color: purple; /* Couleur du T */
        }

        .cell.l {
            background-color: green; /* Couleur du L */
        }
        #gameOverScreen {
            display: none; /* Masqué par défaut */
            position: absolute;
            top: 0;
            left: 0;
            width: 101%;  /* Largeur de la grille */
            height: 101%;
            background-color: rgba(0, 0, 0, 0.5); /* Fond semi-transparent */
            color: white;
            font-size: 36px;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Assurez-vous qu'il soit au-dessus de la grille */
        }

        #gameOverScreen p {
            margin: 0;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.8); /* Fond légèrement plus opaque pour le texte */
            border-radius: 10px;
        }
    </style>
</head>
<body>

<h1>Grille Tetris</h1>
<div class="game-container" id="gameContainer">
    <div class="grid" id="grid"></div>
    <div id="gameOverScreen">
        <p>Game Over</p>
    </div>
</div>
<button id="startPauseButton">Démarrer</button>
<script>
    let currentPieceTemplate = null;
    const grid = document.getElementById('grid');
    const rows = 20, cols = 10;
    let currentPiece = null;
    let gameInterval = null;
    const fixedCells = Array(rows * cols).fill(false);
    const startPauseButton = document.getElementById('startPauseButton');
    const gameOverScreen = document.getElementById('gameOverScreen'); // Écran Game Over
    let isOff = true;
    let isPaused = true;    // Variables de contrôle

    function toggleGame() {
        if(isOff){
            spawnPiece();
            gameInterval = setInterval(gameLoop, 500);
            startPauseButton.textContent = "Pause";
            isPaused = false;
            isOff = false;
        }
        else if (isPaused) {
            gameInterval = setInterval(gameLoop, 500);
            startPauseButton.textContent = "Pause";
            isPaused = false;
        } else {
            clearInterval(gameInterval); 
            startPauseButton.textContent = "Démarrer";
            isPaused = true;
        }
    }


    for (let i = 0; i < rows * cols; i++) {
        const cell = document.createElement('div');
        cell.classList.add('cell');
        grid.appendChild(cell);
    }
    const cells = document.querySelectorAll('.cell');

    const pieces = [
        [0, 1, cols, cols + 1], // Carré
        [1, cols, cols + 1, cols + 2], // T
        [0, cols, cols + 1, cols + 2], // L
    ];
    const pieceClasses = ['square', 't', 'l']; // Correspondance entre les pièces et leurs classes CSS

    function drawPiece(piece, remove = false) {
        const pieceClass = pieceClasses[pieces.indexOf(currentPieceTemplate)]; // Obtenez la classe de la pièce actuelle
        piece.forEach(index => {
            if (index >= 0 && index < rows * cols) {
                if (!remove) {
                    cells[index].classList.add('active', pieceClass);
                } else {
                    cells[index].classList.remove('active', pieceClass);
                }
            }
        });
    }


    function movePiece(piece, direction) {
        const newPiece = piece.map(index => index + direction);
        if (newPiece.some(index => 
                index < 0 || 
                index >= rows * cols || 
                (fixedCells[index] && !piece.includes(index)) || 
                (piece.some(i => i % cols === 0) && newPiece.some(i => i % cols === cols - 1)) ||
                (piece.some(i => i % cols === cols - 1) && newPiece.some(i => i % cols === 0)) || isPaused === true)) {
            return piece; // Si collision, conserver l'ancienne position
        }
        drawPiece(piece, true);
        drawPiece(newPiece);
        return newPiece;
    }

    // Fonction pour fixer une pièce
    function fixPiece(piece) {
        piece.forEach(index => {
            if (index >= 0 && index < rows * cols) {
                fixedCells[index] = true;
                cells[index].classList.remove('active');
                cells[index].classList.add('fixed');
            }
        });
    }

    function clearFullLines() {
    for (let row = rows - 1; row >= 0; row--) { // Parcourir les lignes du bas vers le haut
        const startIndex = row * cols;
        const endIndex = startIndex + cols;

        // Vérifier si la ligne est pleine
        const isFull = fixedCells.slice(startIndex, endIndex).every(cell => cell);

        if (isFull) {
            // Supprimer les classes des cellules visuellement
            for (let i = startIndex; i < endIndex; i++) {
                cells[i].className = 'cell'; // Réinitialiser les classes des cellules
                fixedCells[i] = false;
            }

            // Descendre les cellules fixes au-dessus de cette ligne
            for (let i = startIndex - 1; i >= 0; i--) {
                const belowIndex = i + cols;

                if (fixedCells[i]) {
                    // Copier les classes de couleur de la cellule actuelle à la cellule en dessous
                    cells[belowIndex].className = cells[i].className;

                    // Déplacer l'état fixe vers la cellule en dessous
                    fixedCells[belowIndex] = true;

                    // Libérer la cellule actuelle
                    fixedCells[i] = false;
                    cells[i].className = 'cell'; // Réinitialiser les classes
                }
            }

            // Vérifier la même ligne à nouveau car elle a été remplacée par celles du dessus
            row++;
        }
    }
}


    // Initialiser une nouvelle pièce
    function spawnPiece() {
        const randomIndex = Math.floor(Math.random() * pieces.length);
        currentPieceTemplate = pieces[randomIndex];
        currentPiece = currentPieceTemplate.map(index => index + 4);
        drawPiece(currentPiece);
    }

    // Boucle du jeu
    function getFixedCellsMatrix() {
        const matrix = [];
        for (let row = 0; row < rows; row++) {
            const startIndex = row * cols;
            const rowArray = fixedCells.slice(startIndex, startIndex + cols)
                .map(cell => cell ? 1 : 0);
            matrix.push(rowArray);
        }
        return matrix;
    }

    function printFixedCellsMatrix() {
        const matrix = getFixedCellsMatrix();
        matrix.forEach(row => {
            console.log(row.join(' '));  // Afficher chaque ligne avec des espaces entre les valeurs
        });
    }

    function checkGameOver() {
        const firstRowStartIndex = 0;
        const firstRowEndIndex = cols;  // Les indices de la première ligne vont de 0 à 9 (cols - 1)

        // Vérifier si une case de la première ligne est fixée
        for (let i = firstRowStartIndex; i < firstRowEndIndex; i++) {
            if (fixedCells[i]) {
                gameOverScreen.style.display = 'flex';  // Afficher l'écran "Game Over"
                clearInterval(gameInterval);  // Arrêter le jeu
                return true;  // Indiquer que le jeu est terminé
            }
        }
        return false;
    }

    function gameLoop() {
        if (currentPiece) {
            const newPiece = movePiece(currentPiece, cols);

            // Vérifier si la pièce doit être fixée
            if (newPiece === currentPiece || newPiece.some(index => index >= rows * cols || fixedCells[index])) {
                fixPiece(currentPiece);
                clearFullLines();
                printFixedCellsMatrix();  
                if (checkGameOver()) {
                    return;  // Ne pas continuer la boucle si le jeu est terminé
                }
                spawnPiece();
            } else {
                currentPiece = newPiece;
            }
        }
    }



    // Contrôles utilisateur
    document.addEventListener('keydown', (e) => {
        if (!currentPiece) return;
        if (e.key === 'ArrowLeft') currentPiece = movePiece(currentPiece, -1); // Déplacement à gauche
        if (e.key === 'ArrowRight') currentPiece = movePiece(currentPiece, 1); // Déplacement à droite
        if (e.key === 'ArrowDown') currentPiece = movePiece(currentPiece, cols); // Déplacement rapide vers le bas
    });
    startPauseButton.addEventListener('click', toggleGame);
</script>

</body>
</html>
